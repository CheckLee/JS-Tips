# 1. 算法思路
> 经验有限；只能够给自己说明白，能知道解法也就下面这些。以后看了算法公开课再来补充。

<!-- TOC -->

- [1. 算法思路](#1-算法思路)
  - [一句话](#一句话)
  - [1.1. 递归](#11-递归)
  - [动态规划](#动态规划)
  - [两个指针](#两个指针)

<!-- /TOC -->

## 一句话

学好数学，其实这些都是有数学理论支撑的。我看了网易公开课前面几集的结论。

## 1.1. 递归

> **先不考虑性能问题**，递归好理解但是性能有问题需要优化

1. 其实递归有递归表达式，例如求解`[1, 1, 2, 3, 5...]`此类后一个是前两个相加结果。

那么递归表达式解释`f(n)=f(n-1)+f(n-2)`，有没有发现其实这就是一个数学公式！！以前上学的时候怎么不知道这个解法。

再比如求解阶乘，`!n=n*n-1*n-2...*1`。可以理解为`f(n)=n*f(n-1)`。

递归需要考虑2个问题：

1. 在递归边界外(例如上面式子成立条件是`n>=0`，所以要在`n<=2`)中止递归
2. 在递归边界内求解递归(就是上面那个表达式)`f(n)=f(n-1)+f(n-2)`

转化为具体的代码为：

```JavaScript
// 先写出f(n)
function f (n) {
  // 递归边界外
  if (n <= 2) {
    return 1
  }
  // 递归边界内
  return f(n-1) + f(n-2)
}
```

**是不是还挺好理解的**

2. 没有递归表达式，这个一点点补充

> 需要利用到上一个函数结果，来改变当前结果。然后返回当前结果。

## 动态规划

> 和递归一样也是有一定数学理论

高中数学或者初中数学有一个很重要的推导方法。想要证明一个式子成立：

1. `f(1)`成立，这是基础
2. 假设`f(n-1)`成立
3. 如果在`f(n-1)`成立基础上`f(n)`成立，那么`f(n)`这个表达式成立

动态规划类似，它假设

1. `f(1)`有最优解
2. `f(2)`在`f(1)`最优解基础上得到最优解

然后一直推导到最后一个`f(n)`

没错这个还是有递归...。但是 **最优解以及当前函数需要利用到上一个函数结果是它的特点。**

## 两个指针

> 因为我发现这个还能解决蛮多问题的

来源于[JS-快速排序算法.js]()。有事没事头尾设置两个指针看看能不能简化你的问题。